<?php
/**
 * @file
 * Provide an API for linkback-handlers to support linkback-registration on
 * nodes.  At least one linkback-handler (such as Pingback or Trackback) should
 * be enabled.
 */


/**
 * @defgroup linkback_validation_error_codes Linkback error codes.
 * @{
 * Numeric error codes used to report errors when recording the receipt of a
 * linkback.
 * @}
 */

/**
 * @addtogroup linkback_validation_error_codes
 * @{
 */

// Zero means the linkback is valid.
define('LINKBACK_VALIDATES', 0);

// The local node could not be found.
define('LINKBACK_ERROR_LOCAL_NODE_NOT_FOUND', 1);

// The local node could not be used as a linkback resource (e.g. linkbacks are
// disabled on the node).
define('LINKBACK_ERROR_LOCAL_NODE_LINKBACK_NOT_ALLOWED', 2);

// The pingback has previously been registered.
define('LINKBACK_ERROR_LINKBACK_ALREADY_REGISTERED', 3);

// The URL of the remote site could not be reached.
define('LINKBACK_ERROR_REMOTE_URL_NOT_FOUND', 4);

// The response from the remote resource does not contain a link to this site.
define('LINKBACK_ERROR_REMOTE_URL_MISSING_LINK', 5);


/**
 * @} End of "addtogroup linkback_validation_error_codes".
 */

/**********************************************************
 * Hook implementations.
 *********************************************************/

/**
 * Implements hook_help().
 */
function linkback_help($path, $arg) {
  // Explain:
  // - Linkback protocol
  // - Trackback protocol
  // Send vs Receive
  // Adding as comments/entities...
  // Moderation (Mollom integration?)

  switch ($path) {
    // Main help for the Linkback module.
    case 'admin/help#linkback':
      break;

    // The configuration page.
    case 'admin/config/content/linkback':
      $output = '';
      $output .= '<p>' . t('The linkback handlers are prioritised by module-weight.') .'</p>';
      return $output;
  }
}

/**
 * Implements hook_permission().
 */
function linkback_permission() {
  $perms = array();
  // This permission controls access to the admin-settings page, and
  // automatically grants access to configure linkback settings on any node-
  // type that the user has permission to edit.
  $perms['configure linkback settings'] = array(
    'title' => t('Administer linkback settings'),
  );

  foreach (node_permissions_get_configured_types() as $type) {
    $perms += _linkback_list_permissions($type);
  }
  return $perms;
}

/**
 * Implements hook_theme().
 */
function linkback_theme() {
  return array(
    'linkback_settings_handlers_form_element' => array(
      'render element' => 'form',
      'file' => 'linkback.admin.inc',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function linkback_menu() {
  $items['admin/config/content/linkback'] = array(
    'title' => 'Linkback',
    'description' => 'Configure trackbacks and pingbacks.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('linkback_settings_form'),
    'access arguments' => array('configure_linkback_settings'),
    'file' => 'linkback.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Configure which content-types can send/receive linkbacks.
 */
function linkback_form_node_type_form_alter(&$form, &$form_state) {
  $type = $form['#node_type'];

  // The JS adds an appropriate description to the vertical-tab for Linkbacks
  // based on the chosen settings.
  $form['additional_settings']['#attached']['js'][] = drupal_get_path('module', 'linkback') . '/linkback_content_types.js';

  $form['linkback'] = array(
    '#type' => 'fieldset',
    '#title' => t('Linkbacks'),
    '#description' => t('Default settings for new content:'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings',
  );
  $form['linkback']['linkback_receive'] = array(
    '#type' => 'checkbox',
    '#title' => t('Receive linkbacks'),
    '#description' => t('Allow %type nodes to receive linkbacks from third party sites.', array('%type' => $type->name)),
    '#default_value' => variable_get("linkback_receive_{$type->type}", TRUE),
  );
  $form['linkback']['linkback_send'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send linkbacks'),
    '#description' => t('Allow %type nodes to send linkbacks to third party sites when the node is created or changed.', array('%type' => $type->name)),
    '#default_value' => variable_get("linkback_send_{$type->type}", TRUE),
  );
}

/**
 * Implements hook_form_alter().
 */
function linkback_form_alter(&$form, $form_state, $form_id) {

  // Add 'send' and 'receive' controls to node/add and node/nnn/edit forms.
  if (strpos($form_id, '_node_form') && isset($form['#node'])) {
    $node = $form['#node'];
    $node_type = $form['#node']->type;

    // Get the configured linkback settings for this node (if already set), or
    // the defaults for the node's content-type.
    $settings = (object) array(
      'send'    => isset($node->linkback_send)    ? $node->linkback_send    : variable_get("linkback_send_{$node_type}", TRUE),
      'receive' => isset($node->linkback_receive) ? $node->linkback_receive : variable_get("linkback_receive_{$node_type}", TRUE),
    );

    // Users may control whether linkbacks (send / receive) are enabled for a
    // given node if they have permission for that node-type, or a global admin
    // permission.
    $access = user_access("configure {$node_type} linkbacks") || user_access('administer content types') || user_access('configure linkback settings');

    // The JS handles the vertical-tabs text.
    $form['additional_settings']['#attached']['js'][] = drupal_get_path('module', 'linkback') . '/linkback_content_types.js';

    $form['linkback'] = array(
      '#type' => 'fieldset',
      '#title' => t('Linkbacks'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
      '#access' => $access,
    );
    $form['linkback']['linkback_receive'] = array(
      '#type' => 'checkbox',
      '#title' => t('Receive linkbacks'),
      '#default_value' => $settings->receive,
    );
    $form['linkback']['linkback_send'] = array(
      '#type' => 'checkbox',
      '#title' => t('Send linkbacks'),
      '#default_value' => $settings->send,
    );
  }
}

/**
 * Implements hook_node_load().
 *
 * When a node is loaded, add the 'send' and 'receive' linkback attributes to
 * the node object.
 */
function linkback_node_load($nodes, $types) {
  $nids = array_keys($nodes);

  // Load the linkback settings for these nodes.
  $linkback_node_settings = _linkback_node_get_settings($nids);

  foreach ($nids as $nid) {
    // If this node has already been configured, use the node's settings.
    if (array_key_exists($nid, $linkback_node_settings)) {
      $nodes[$nid]->linkback_send    = $linkback_node_settings[$nid]->send;
      $nodes[$nid]->linkback_receive = $linkback_node_settings[$nid]->receive;
    }
    // Fallback to defaults.
    else {
      $node_type = $nodes[$nid]->type;
      $nodes[$nid]->linkback_send    = variable_get("linkback_send_{$node_type}", TRUE);
      $nodes[$nid]->linkback_receive = variable_get("linkback_receive_{$node_type}", TRUE);
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function linkback_node_insert($node) {
  _linkback_node_save($node);
}

/**
 * Implements hook_node_update().
 */
function linkback_node_update($node) {
  _linkback_node_save($node);
}



/**
 * Implements hook_linkback_get_external_links().
 * Gets all the URLs found in the body field of a node.
 *
 * @return Array
 * A list of external links found within the BODY field.
 */
function linkback_linkback_get_external_links($node) {
  $text = _linkback_extract_text($node);
  return _linkback_extract_urls($text);
}

/**
 * Implements hook_linkback_link_send_alter().
 *
 * Hook function provided on behalf of core's path functionality to support
 * URL aliases for nodes.
 */
function linkback_linkback_link_send_alter(&$links, $node) {
  foreach ($links as $key => $record) {
    $language = (isset($node->language)) ? $node->language : LANGUAGE_NONE;
    if ($url = drupal_lookup_path('alias', $record->source, $language)) {
      $links[$key]->source = $url;
    }
  }
}



/**********************************************************
 * Public API functions.
 *********************************************************/

/**
 * Register the receipt of a linkback.
 *
 * If the linkback has not been validated, this function will call the
 * validation handlers.
 * This function will trigger linkback actions (such as add-comment) when a
 * linkback has been successfully validated.
 *
 * @param Object $linkback A linkback object.
 *
 * @return Int
 * 0 is returned if the linkback was successfully added.
 * A positive numeric error-code is returned if the linkback was declined (e.g.
 * the linkback already exists, or an anti-spam module prevented the pingback,
 * etc). @see linkback_validation_error_codes.
 */
function linkback_receive(linkback $linkback) {

  // Validate the linkback request, if it's not already validated.
  if (empty($linkback->validated)) {
    $validation_result = linkback_receive_validate($linkback);

    // If it's invalid, abort here.
    if (!$validation_result == LINKBACK_VALIDATES) {
      return $validation_result;
    }
  }

  // Write an entry in the linkback tracker table.
  db_merge('node_linkback_received')
    ->key(array(
      'nid' => $linkback->nid,
      'url' => $linkback->url,
      ))
    ->fields(array(
      'handler'   => $linkback->handler,
      'origin_ip' => $linkback->origin_ip,
      'timestamp' => $linkback->timestamp,
    ))
    ->execute();

  // Fire hook_linkback_received_action().
  // Actions are implemented through:
  // - linkback_trigger - supports the core trigger module.
  // - linkback_rules - integrates with the rules module.
  module_invoke_all('linkback_received_action', $linkback);

}


/**
 * Validate the receipt of a linkback.
 *
 * @param Object $linkback A linkback object.
 *
 * @return Int
 * 0 is returned if the linkback validates.
 * A positive numeric error-code is returned if the linkback validation fails
 * (e.g. the linkback already exists, or an anti-spam module prevented the
 * pingback, etc).
 *
 * @see linkback_validation_error_codes.
 */
function linkback_receive_validate(linkback $linkback) {
  // Validate that the node accepts pingbacks.
  $node = node_load($linkback->nid);
  if (!$node) {
    return LINKBACK_ERROR_LOCAL_NODE_NOT_FOUND;
  }
  // Check that the node permits linkbacks.
  elseif (!linkback_node_allows_linkback($node, 'receive')) {
    return LINKBACK_ERROR_LOCAL_NODE_LINKBACK_NOT_ALLOWED;
  }
  // Check that the linkback isn't already registered.
  elseif (linkback_is_received($linkback->nid, $linkback->url)) {
    return LINKBACK_ERROR_LINKBACK_ALREADY_REGISTERED;
  }

  // Optional validation:
  // Validate that the remote URL is reachable and links to the referenced
  // node.
  if (variable_get('linkback_validate_remote_pages', FALSE)) {
    // Validate that the remote node is reachable.
    $result = drupal_http_request($linkback->url);

    // Treat all HTTP errors (inc Forbidden) as remote URL not found.
    if ($result->error) {
      return LINKBACK_ERROR_REMOTE_URL_NOT_FOUND;
    }

    // Check the content for a link to the local node.
    $content = $result->data;
    // Extract all the URLs from the page content.
    $urls = _linkback_extract_urls($content);
    $matched = FALSE;
    foreach ($urls as $url) {
      if ($nid = linkback_lookup_nid($url)) {
        $matched = TRUE;
        break;
      }
    }
    if (!$matched) {
      return LINKBACK_ERROR_REMOTE_URL_MISSING_LINK;
    }
  }

  // @TODO: Allow other modules to add their own validation routines.

  return LINKBACK_VALIDATES;
}


/**
 * Parse a node and send linkbacks to the discovered URLs (which haven't 
 * already recorded a successful linkback).
 * Note that this function does not respect the node's "linkback_send" property
 * - modules which invoke this function directly should check the node's
 * settings first to ensure the node permits linkbacks to be sent.
 *
 * @param Object $node
 * A fully loaded node object (or one which is in the process of being saved).
 */
function linkback_node_process($node) {
  // Look for external links.
  $links = linkback_get_external_links($node);
  linkback_send_linkbacks($links, $node);
}

/**
 * Check if a node allows linkback operations.
 *
 * @param Object $node
 * The node to check.
 * @param String $op
 * One of:
 * - send
 * - receive
 *
 * @return Boolean
 */
function linkback_node_allows_linkback($node, $op) {
  // Both send and receive ops depend on the node allowing anonymous access.
  if (!node_access('view', $node, drupal_anonymous_user())) {
    return FALSE;
  }

  switch ($op) {
    case 'send':
      return isset($node->linkback_send) ? $node->linkback_send : variable_get("linkback_send_{$node->type}", TRUE);

    case 'receive':
      return isset($node->linkback_receive) ? $node->linkback_receive : variable_get("linkback_receive_{$node->type}", TRUE);
  }
}

/**
 * Get a list of external links from a node.
 *
 * This uses hook_linkback_get_external_links.  By default, the linkback module
 * checks only the BODY field.  Create an implementation of
 * hook_linkback_get_external_links() to check other fields.
 *
 * @param Object $node
 * The node to check.
 *
 * @return array
 * An array of external link URLs.
 */
function linkback_get_external_links($node) {
  $links = module_invoke_all('linkback_get_external_links', $node);
  return $links;
}


/**
 * Invoke linkback handlers on each external link to record a linkback.
 *
 * @param Array $links
 * An array of external URLs.
 */
function linkback_send_linkbacks($links, $node) {
  // The initial source URL is defined as node/xxx.  The linkback module
  // provides an implementation of hook_linkback_link_send_alter for the path
  // module to support node-aliases.
  $source = "node/{$node->nid}";

  // Build up a list of linkback records for altering.
  $records = array();
  foreach ($links as $link) {
    $records[$link] = (object) array(
      'source' => $source,
      'target' => $link,
    );
  }

  // Invoke hook_linkback_link_send_alter(). The node property is unalterable.
  drupal_alter('linkback_link_send', $records, $node);

  foreach ($records as $record) {
    if (!linkback_is_sent($node->nid, $record->target)) {
      linkback_send_single_linkback($record->source, $record->target, $node);
    }
  }
}

/**
 * Invoke linkback handlers to send a linkback.
 *
 * @param String $source
 * The canonical URL of the local node.
 * @param String $target
 * The URL of the remote page.
 * @param Object $node
 * The local node object.
 *
 * @return Boolean
 * TRUE if the remote server accepts the linkback request.
 */
function linkback_send_single_linkback($source, $target, $node) {
  // Record the timestamp of this attempt in the {node_linkback_sent} table.
  // This allows linkbacks which have not been successful to be re-attempted
  // periodically.
  db_merge('node_linkback_sent')
    ->key(array(
      'nid' => $node->nid,
      'url' => $target,
      ))
    ->fields(array(
      'timestamp' => time(),
    ))
    ->execute();

  $handlers = linkback_get_handler();
  foreach ($handlers as $handler) {
    // Invoke hook_linkback_send().
    $callback = $handler->module . '_linkback_send';
    $success = $callback($target, $source, $node);

    // If the handler reports success, log this as a successful request.
    if ($success) {
      db_merge('node_linkback_sent')
        ->key(array(
          'nid' => $node->nid,
          'url' => $target,
          ))
        ->fields(array(
          'linkback_handler' => $handler->module,
        ))
        ->execute();
      // Stop at the first successful handler.
      return TRUE;
    }
  }
  return FALSE;
}


/**
 * Fetch the node nid from a local URL.
 *
 * Handles standard drupal paths such as node/1 and drupal aliases.
 *
 * @param String $url
 * The URL of a node on this site.
 *
 * @return Int|FALSE
 * The node nid (if a match for the URL is found), or FALSE.
 */
function linkback_lookup_nid($url) {
  // Strip the domain from the URL (if present).
  if (preg_match('#^(https?://[^/]+/).*#', $url, $matches)) {
    $url = substr($url, strlen($matches[1]));
  }

  // Lookup URL aliases.
  if ($local_path = drupal_lookup_path('source', $url)) {
    $url = $local_path;
  }

  if (preg_match('#^node/(\d+)$#', $url, $matches)) {
    return (int) $matches[1];
  }
  return FALSE;
}

/**
 * Check if a linkback has already been received for a particular node/URL.
 *
 * @param Int $nid
 * The node nid.
 * @param String $url
 * The URL of the external site.
 *
 * @return Boolean
 * TRUE if the linkback has already been registered.
 */
function linkback_is_received($nid, $url) {
  $result = db_select('node_linkback_received', 'nlr', array('target' => 'slave'))
    ->fields('nlr', array('nid'))
    ->condition("nlr.nid", $nid)
    ->condition("nlr.url", $url)
    ->execute()
    ->fetchField();
  return (bool) $result;
}

/**
 * Check if a linkback has already been sent for a particular node/URL.
 *
 * @param Int $nid
 * The node nid.
 * @param String $url
 * The URL of the external site.
 *
 * @return Boolean
 * TRUE if the linkback has already been sent.
 */
function linkback_is_sent($nid, $url) {
  $result = db_select('node_linkback_sent', 'nls', array('target' => 'slave'))
    ->fields('nls', array('nid'))
    ->condition("nls.nid", $nid)
    ->condition("nls.url", $url)
    ->isNotNull('nls.linkback_handler')
    ->execute()
    ->fetchField();
  return (bool) $result;
}

/**
 * Get a list of linkback-handlers and their attributes.
 *
 * @return Array
 * An array of linkback handler objects. Each handler has the properties:
  * - module   The system-name of the module.
  * - protocol The human-readable name of the linkback protocol provided.
  * - weight   The weight of the module.
 */
function linkback_get_handler($handler = NULL) {
  $handlers = linkback_load_all_handlers();
  if (is_null($handler)) {
    return $handlers;
  }
  else if (isset($handlers[$handler])) {
    return $handlers[$handler];
  }
  else {
    return NULL;
  }
}

/**
 * Fetch a list of all the linkback handlers.
 *
 * @param optional Boolean $reset_cache
 * Set to TRUE to force a relooad of the handlers from their hooks.
 *
 * @return Array
 * A list of linkback handlers, ordered according to the priority from most
 * important to least. Each handler has the properties:
 * - module   The system-name of the module.
 * - protocol The human-readable name of the linkback protocol provided.
 * - weight   The weight of the module.
 */
function linkback_load_all_handlers($reset_cache = FALSE) {
  if (!($reset_cache) && $cache = cache_get('linkback_handlers')) {
    $handlers = $cache->data;
  }
  else {
    // Invoke hook_linkback_handler().
    // module_invoke_all() will order the results by module-weight: no further
    // sorting required.
    $linkback_handler_modules = module_implements('linkback_handler');

    $weights = _linkback_get_module_weights($linkback_handler_modules);
    $handlers = array();
    foreach ($linkback_handler_modules as $module) {
      $callback = "{$module}_linkback_handler";

      $handlers[$module] = (object) $callback();
      $handlers[$module]->module = $module;
      $handlers[$module]->weight = $weights[$module];
    }
    cache_set('linkback_handlers', $handlers);
  }

  return $handlers;
}

/**
 * Set the weights of modules.
 *
 * @param Array $weights
 * Array of module weights, keyed by the system-name of the module.
 */
function linkback_set_weights($weights) {
  foreach ($weights as $module => $weight) {
    _linkback_set_weight($module, $weight);
  }

  // We need to rebuild the module-weight cache when this is called.
  cache_clear_all('hook_info',         'cache_bootstrap');
  cache_clear_all('module_implements', 'cache_bootstrap');
  cache_clear_all('system_list',       'cache_bootstrap');
  cache_clear_all('linkback_handlers', 'cache');
}



/**********************************************************
 * Private API handlers.
 *********************************************************/

/**
 * Fetch the node-settings (whether send/receive is enabled) for one or more
 * nodes.
 *
 * @param Int|Array $nids
 * Either a single node nid, or an array of node nids.
 *
 * @return Array
 * An array of settings objects (each with the properties 'nid', 'send' and
 * 'receive'), indexed by node nid.
 */
function _linkback_node_get_settings($nids) {
  if (is_numeric($nids)) {
    $nids = array($nids);
  }

  $result = db_select('node_linkback_settings', 'nls', array('target' => 'slave'))
    ->fields('nls', array('nid', 'send', 'receive'))
    ->condition("nls.nid", $nids, 'IN')
    ->execute()
    ->fetchAllAssoc('nid');

  return $result;
}

/**
 * Save the linkback-settings for a node, scan the node for links, and fire off
 * linkbacks as needed.
 */
function _linkback_node_save($node) {
  // If a custom send/receive setting has not been provided, use the default
  // setting for this node-type.
  $settings = array(
    'send'    => isset($node->linkback_send)    ? (bool) $node->linkback_send    : variable_get("linkback_send_{$node->type}", TRUE),
    'receive' => isset($node->linkback_receive) ? (bool) $node->linkback_receive : variable_get("linkback_receive_{$node->type}", TRUE),
  );

  // Update the flags in {node_linkback_settings}.
  db_merge('node_linkback_settings')
    ->key(array(
      'nid' => $node->nid,
      ))
    ->fields(array(
      // Cast the booleans to an int, to match the db data-type.
      'send'    => (int) $settings['send'],
      'receive' => (int) $settings['receive'],
    ))
    ->execute();


  if ($settings['send']) {
    // TODO: do this now or later?
    linkback_node_process($node);
  }
}

/**
 * Get the module-weights for a set of modules (used to fetch the weights of
 * the linkback-handler modules).
 *
 * @param Array $modules
 * An array of module names.
 *
 * @return Array
 * An array of module-weights, keyed by module name.
 */
function _linkback_get_module_weights($modules) {
  if (!is_array($modules) || empty($modules)) {
    return array();
  }

  $result = db_select('system', 's', array('target' => 'slave'))
    ->fields('s', array('name', 'weight'))
    ->condition('s.type', 'module')
    ->condition("s.name", $modules, 'IN')
    ->orderBy('weight', 'ASC')
    ->orderBy('filename', 'ASC')
    ->execute()
    ->fetchAllAssoc('name');

  $weights = array();
  foreach ($result as $module => $row) {
    $weights[$module] = $row->weight;
  }
  return $weights;
}

/**
 * Set the weight of a module.
 *
 * @param String $module
 * The system name of the module.
 * @param Int $weight
 * The new weight to set.
 */
function _linkback_set_weight($module, $weight) {
  db_merge('system')
    ->key(array(
      'type' => 'module',
      'name' => $module,
      ))
    ->fields(array(
      'weight' => $weight
    ))
    ->execute();
}

/**
 * Helper function to generate standard linkback permission list for a given type.
 *
 * @param $type
 *   The machine-readable name of the node type.
 * @return array
 *   An array of permission names and descriptions.
 */
function _linkback_list_permissions($type) {
  $info = node_type_get_type($type);
  $type = check_plain($info->type);

  // Build standard list of node permissions for this type.
  $perms = array(
    "configure $type linkbacks" => array(
      'title' => t('%type_name: Configure linkbacks', array('%type_name' => $info->name)),
      'description' => t('This is only available to users who already have permission to edit the content.'),
    ),
  );

  return $perms;
}

/**
 * Extract text from a single field-API field.
 */
function _linkback_extract_text($node) {
  $langcode = field_language('node', $node, 'body');
  // Assume that $node->body[$langcode][0] is present.
  $item = $node->body[$langcode][0];

  // Use the API to generate a renderable array.  This allows all the regular
  // field-alter hooks to fire, so we get the same text as it would be rendered
  // on the page.
  $field = field_view_value('node', $node, 'body', $item);
  $text = drupal_render($field);

  return $text;
}

/**
 * Extract all the external URLs from a single string.
 */
function _linkback_extract_urls($text) {
  // Regexp is stolen from trackback.module ;)
  preg_match_all("/(http|https):\/\/[a-zA-Z0-9@:%_~#?&=.,\/;-]*[a-zA-Z0-9@:%_~#&=\/;-]/", $text, $urls);
  // TODO: check that the URLs are external, and not local FQDN.
  return array_unique($urls[0]);
}
